from email.mime.multipart import MIMEMultipart
import os
import base64
import threading
from threading import Event
import json
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import webbrowser
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from email.mime.text import MIMEText

from ..utilities.resource_path import resource_path

"""
Generated by ChatGPT

This code provides an interface to the Gmail API for sending emails. It includes authentication handling using OAuth 2.0,
web server setup for local redirection during the OAuth flow, and functions for sending both plain text and HTML emails.
"""


class GmailService:
    """
    Manages authentication and interaction with the Gmail API to send emails.

    This service class handles OAuth2 authentication, token management, and provides functionalities
    to send emails. It uses a local server setup to handle OAuth redirects.

    Attributes:
        credentials (Credentials): The OAuth2 credentials for accessing Gmail API.
        service (Resource): The Google API service object.
        auth_code (str): The authorization code received from OAuth flow.
        auth_code_event (Event): Event to synchronize the OAuth authentication flow.
    """
    SCOPES = ['https://www.googleapis.com/auth/gmail.send']
    REDIRECT_URI = 'http://localhost:8080/'
    
    def __init__(self):
        self.credentials = None
        self.service = None
        self.auth_code = None
        self.auth_code_event = Event()


    def authenticate(self, client_id, client_secret):
        """
        Initiates the OAuth2 flow using a web-based authorization approach. Opens a web browser for the user to grant
        permissions and waits for a callback on a local server.

        Args:
            client_id (str): The client ID for the OAuth application.
            client_secret (str): The client secret for the OAuth application.

        Returns:
            bool: True if authentication was successful and credentials are set, otherwise False.
        """
        flow = InstalledAppFlow.from_client_config(
            {
                "web": {
                    "client_id": client_id,
                    "client_secret": client_secret,
                    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                    "token_uri": "https://oauth2.googleapis.com/token"
                }
            },
            scopes=self.SCOPES,
            redirect_uri=self.REDIRECT_URI)
        
        auth_url, _ = flow.authorization_url(prompt='consent')
        webbrowser.open_new(auth_url)


        def AuthHandlerFactory(service):
            """
            Factory function to create a custom AuthHandler that can access the GmailService instance.
            """
            class CustomAuthHandler(BaseHTTPRequestHandler):
                def do_GET(self):
                    query = urlparse(self.path).query
                    query_components = parse_qs(query)
                    if 'code' in query_components:
                        service.auth_code = query_components['code'][0]
                        service.auth_code_event.set()

                        self.send_response(200)
                        self.send_header('Content-type', 'text/html')
                        self.end_headers()
                        try:
                            with open(resource_path('web/login_success.html'), 'r', encoding='utf-8') as file:
                                html_content = file.read()
                                self.wfile.write(html_content.encode('utf-8'))
                        except FileNotFoundError:
                            self.wfile.write(b"Error: HTML file not found.")
                        except Exception as e:
                            self.wfile.write(b"Error loading HTML content.")
                    else:
                        self.send_error(401)
            return CustomAuthHandler
        
        httpd = HTTPServer(('', 8080), AuthHandlerFactory(self))
        server_thread = threading.Thread(target=httpd.serve_forever)
        server_thread.daemon = True
        server_thread.start()

        self.auth_code_event.wait()  # Wait for the auth code event to be set by the AuthHandler.
        flow.fetch_token(code=self.auth_code)
        self.credentials = flow.credentials

        httpd.shutdown()
        server_thread.join()

        return self.credentials is not None


    def build_service(self):
        """
        Initializes the Gmail API service object using the authenticated credentials.

        Raises:
            Exception: If credentials are not available or invalid.
        """
        if not self.credentials:
            raise Exception("No credentials available. Please authenticate first.")
        self.service = build('gmail', 'v1', credentials=self.credentials)


    def send_email(self, to, subject, plain_text, html):
        """
        Sends an email to a specified recipient with given subject and content in both plain text and HTML formats.

        Args:
            to (str): The email address of the recipient.
            subject (str): The subject of the email.
            plain_text (str): The plain text version of the email content.
            html (str): The HTML version of the email content.

        Returns:
            bool: True if the email was sent successfully, False if an error occurred.
        """
        if not self.service:
            raise Exception("Service not initialized. Please authenticate and build the service first.")

        message = MIMEMultipart('alternative')
        message['to'] = to
        message['subject'] = subject

        part1 = MIMEText(plain_text, 'plain')
        part2 = MIMEText(html, 'html')

        message.attach(part1)
        message.attach(part2)

        raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode()
        try:
            self.service.users().messages().send(userId='me', body={'raw': raw_message}).execute()
            return True
        except:
            return False